# -*- encoding: utf-8 -*-
"""
**csv2db** is used to import values from one or more csv files into a 
relational database.

*Copyright (C) 2014, ETH Zurich - Swiss Seismological Service SED*


Import Specification
--------------------

The importer creates one or more related DbRecord objects for each row that it
reads from the csv file according to the import specification that is passed
to CsvImporter on init.
These objects can then be converted to sql insert statements.
The import specification is a dictionary with the following format::

    import_specs = {
        <table_name>: {
            <instance_name>: RecordSpec(<attribute_map> [, condition=<cond>])
        },
        <table name>: {
            <instance_name>: RecordSpec(<attribute_map> [, condition=<cond>]),
            <instance_name>: RecordSpec(<attribute_map> [, condition=<cond>]),
            ...
        },
        ...
    }


Here's what the different parts mean:

    <table_name>
        Name of the table in the target database where objects specified by
        the *RecordSpec* instances under this key should be inserted.
    <instance_name>
        An identifier for each record instance that should be created when a
        csv row is imported. I.e. you can create multiple records in the same
        target table per csv row. The *<instance_name>* is just an arbitrary 
        name which the script needs to resolve cross references (see below).
    <attribute_map>
        The attribute map tells the RecordSpec how to fill the columns in the
        target table. See below for details.
    <cond>
        An optional callable that tells the script whether the object should be
        created for one particular row or not. *<cond>* must accept exactly one
        argument which is the currently imported csv row dictionary.


Attribute map specification
---------------------------

A RecordSpec is initialized with an *attr_map* dictionary that specifies how
each column of the target table should be filled with values.
Options are:

    * Values extracted from a column in the csv (:class:`.ColumnValue`)
    * Values computed from multiple columns (:class:`.MultiColumnValue`)
    * Constant values (:class:`.ConstValue`)
    * Dynamically generated values (:class:`.DynamicValue`)
    * Values taken from other DbRecord objects (:class:`.XReference`)

In the example given below, the assumptions are that the target table has a
column named *_oid* whose value is dynamically generated by a callable
OidFactory class. The *_parent_oid* refers to the *_oid* of *other_instance* in
*other_table* (corresponding to a *<table_name>* and *<instance_name>* in the
import_spec. The value for *x_value* is extracted from the csv column
*csv_x_value*. The column m *m_name* is always filled with the string 'Some
Text'. ::

    attr_map = {
        '_oid':        DynamicValue(OidFactory())
        '_parent_oid': XReference('other_table', 'other_instance', '_oid'),
        'x_value':     ColumnValue('csv_x_value'),
        'm_name':      ConstValue("'Some Text'"),
    }

The script takes care of creating records in the correct order so that
XReferences can be resolved (as long as there are no circular references).
ColumnValue takes an additional optional argument *convert*, where you can
specify a function or other callable that converts the value before inserting
it into the record. For MultiColumnValue the *convert* argument is mandatory
and provides the function that contracts the input values into a single
output value.

.. moduleauthor:: Lukas Heiniger

"""

import csv
import re

# Regular expression to detect potential string values with missing quotes
sql_fun = ['true', 'false', 'avg', 'count', 'first', 'last', 'max', 'min',
           'sum', 'ucase', 'lcase', 'mid', 'len', 'round', 'now', 'format']
string_exp = re.compile('^(?!["\']|{}).*[a-z]'.format('|'.join(sql_fun)), 
                        re.IGNORECASE)


class CsvImporter(object):
    """
    CsvImporter imports values from a csv file into records and creates sql
    insert statements to create the corresponding rows in the target db.

    :param path: Path to the csv file to import
    :param dialect: Dictionary with csv reader dialect specifications
        (see http://docs.python.org/2/library/csv.html#csv-fmt-params)
    :param import_specs: Dictionary with import specifications for each
        table. RecordSpecs are used to tell the script how to extract the
        csv columns into db records.
        Each entry can have multiple RecordSpecs, identified by a unique
        key which is used to resolve cross references in the attr_map of
        each RecordSpec.

    """
    def __init__(self, path, dialect, import_specs):
        self.path = path
        self.dialect = dialect
        # Flatten import_specs to {(table, instance): record_spec} "t,i,s" form
        flat_specs = {}
        for (t, table_spec) in import_specs.items():
            specs = {(t, i): s for (i, s) in table_spec.items()}
            flat_specs.update(specs)
        # Create a XReference dependency map and sort it topologically
        dependency_map = {}
        for (path, s) in flat_specs.items():
            deps = set([(x.table_name, x.instance_name) for x
                        in s.attr_map.values() if isinstance(x, XReference)])
            dependency_map[path] = deps
        sorted_keys = [val for sub in _toposort(dependency_map) for val in sub]
        # Store sorted results in a list [(t, i, s), ...]
        try:
            self.specs = [(t, i, flat_specs[(t, i)]) for (t, i) in sorted_keys]
        except KeyError:
            print('ERROR: Could not find specification for "{}" in table '
                  '"{}". Check your XReferences.'.format(i, t))
            exit(-1)



    def import_data(self, id_col=None):
        """
        Imports the csv into DbRecords and returns them.

        The method uses the import specification (import_specs) that was passed
        to the importer on init to convert csv table columns to DbRecord
        objects.

        """
        records = []
        with open(self.path) as f:
            csv.register_dialect('csv2db', **self.dialect)
            reader = csv.DictReader(f, dialect='csv2db')
            row_num = 0
            for row in reader:
                row_id = row[id_col] if id_col else row_num
                records += self._records_for_row(row, row_id);
                row_num += 1
        return records

    def _records_for_row(self, row, row_id):
        """
        Import one single row and return the resulting DbRecord objects

        """
        records = {}
        for (table, instance, spec) in self.specs:
            if spec.condition(row) is False:
                continue
            # Create record and import attributes according to spec
            record = DbRecord(table, row_id)
            record.import_attributes(spec.attr_map, records, row)
            # Keep a reference to each record instance that we create for
            # resolving XReferences in later instances
            instance_path = (table, instance)
            records[instance_path] = record

        return records.values()


class RecordSpec(object):
    """
    Specifications for extracting csv columns into the corresponding
    database record.

    :param attr_map: A dictionary that maps database columns to csv
        columns using any of the ...Value classes below.
    :param condition: An optional callable that returns false if the
        object should not be created for the row that is currently.
        The callable must accept exactly one parameter (the current row).

    """
    def __init__(self, attr_map, condition=None):
        self.attr_map = attr_map
        self.condition = condition if condition else lambda row: True


class ColumnValue(object):
    """ 
    Read an input value from a csv column

    :param col_name: Column name to read the value from
    :param convert: Optional conversion function that takes exactly one
           argument which is the row dict for the currently imported row

    """
    def __init__(self, col_name, convert=None):
        self.col_name = col_name
        self.convert = convert

    def _read(self, row, **kw_args):
        value = row[self.col_name]
        return self.convert(value) if self.convert else value


class MultiColumnValue(object):
    """
    Reads input from multiple columns and contracts them into a single value
    using the (non-optional) callable given in *convert*.

    :param col_names: List of column names to read values from
    :param convert: Conversion function that takes exactly one argument (the
        row dict of the currently imported row) and contracts the values into
        a single return value

    """
    def __init__(self, col_names, convert):
        if not convert:
            raise ValueError('ERROR: You must provide a convert function')
        self.col_names = col_names
        self.convert = convert

    def _read(self, row, **kw_args):
        values = {key: row[key] for key in self.col_names}
        return self.convert(values)


class ConstValue(object):
    """ Always returns the same constant value

    :param value: The value to return for each row

    """
    def __init__(self, value):
        self.value = value

    def _read(self, row, **kw_args):
        return self.value


class DynamicValue(object):
    """ Creates a value dynamically using the callable *generate*

    :param generate: A function or other callable that takes a single argument
        (the current row dict) and returns a single value

    """
    def __init__(self, generate):
        self.generate = generate

    def _read(self, row, **kw_args):
        return self.generate(row)


class XReference(object):
    """ Takes the value of a specific attribute of another record.

    :param table_name: Table name in the import_specs table given to the
        *CsvImporter*
    :param instance_name: Identifies a specific instance under *table_name*
    :param attribute_name: Name of the attribute to return

    """
    def __init__(self, table_name, instance_name, attribute_name):
        self.table_name = table_name
        self.instance_name = instance_name
        self.attribute_name = attribute_name

    def _read(self, row, **kw_args):
        existing_records = kw_args['existing_records']
        path = (self.table_name, self.instance_name)
        value = existing_records[path].attributes[self.attribute_name]
        return value


class DbRecord(object):
    """
    One or more DbRecords are created for each imported row accoding to the
    RecordSpecs.

    """
    def __init__(self, table_name, row_id):
        self.row_id = row_id
        self.table_name = table_name
        self.attributes = {}

    def import_attributes(self, attr_map, existing_records, row):
        """
        Import attributes according to the attr_map and resolve cross
        references to existing_records.

        """
        try:
            imported = {k: v._read(row, existing_records=existing_records)
                        for (k, v) in attr_map.iteritems()}
        except AttributeError:
            k, v = next((k, v) for (k, v) in attr_map.iteritems()
                        if '_read' not in dir(v))
            print('ERROR: The RecordSpec for {} in {} does not seem to be '
                  'valid'.format(k, self.table_name))
            exit(-1)
        self.attributes.update(imported)

    def insert_statement(self):
        """
        Returns the insert statement sequence for the current object

        """
        col = ' (%s)' % ', '.join(self.attributes.keys())

        # sanity checks
        error = False
        for k, v in self.attributes.iteritems():
            if not isinstance(v, str):
                print('ERROR: The value ({}) for "{}" in table "{}" is not a '
                      'string. Make sure your specs only produce string '
                      'values (i.e. \'5\', \'TRUE\', \'"Some text"\', '
                      '...)'.format(v, k, self.table_name))
                error = True
            elif string_exp.match(v):
                print ('WARNING: {} looks like a string value but is not in '
                       'quotes. If "{}" in "{}" is a CHAR or VARCHAR type '
                       'column, you should put the value in quotes.').\
                       format(v, k, self.table_name)
        if error:
            print 'Aborting due to errors.'
            exit(-1)
        val = ' (%s)' % ', '.join(self.attributes.values())
        sql = 'INSERT INTO ' + self.table_name + col + ' VALUES' + val + ';\n'
        return sql


# Private (internal) methods

def _toposort(data):
    """
    Sort dependencies topologically

    :param data: Dependency map of the form
        data = {
            'business': set(['fleet','address']),
            'device': set(['business','model','status','pack']),
            'txn': set(['device','business','operator'])
        }

    """
    # Ignore self dependencies.
    for k, v in data.items():
        v.discard(k)
    # Find all items that don't depend on anything.
    extra_items = reduce(set.union, data.itervalues()) - set(data.iterkeys())
    # Add empty dependences where needed
    data.update({item: set() for item in extra_items})
    while True:
        ordered = set(item for item, dep in data.iteritems() if not dep)
        if not ordered:
            break
        yield ordered
        data = {item: (dep - ordered)
                for item, dep in data.iteritems() if item not in ordered}
    assert not data, "Cyclic dependencies:\n%s" % \
        '\n'.join(repr(x) for x in data.iteritems())
